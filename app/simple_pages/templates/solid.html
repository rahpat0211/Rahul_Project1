<!doctype html>
<html lang="en">
<head>
    <!-- Required meta tags -->
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <!-- Bootstrap CSS -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/css/bootstrap.min.css" rel="stylesheet"
          integrity="sha384-1BmE4kWBq78iYhFldvKuhfTAU6auU8tT94WrHftjDbrCEXSU1oBoqyl2QvZ6jIW3" crossorigin="anonymous">

    {% block head %}
        <link rel="stylesheet" href="{{ url_for('static', filename='css/solid.css') }}"/>

        <title>SOLID</title>
    {% endblock %}

</head>
<body>
<button onclick="topFunction()" id="myBtn" title="Go to top">Top</button>
<div class="container">
    <header class="d-flex flex-wrap justify-content-center py-3 mb-4 border-bottom">
        <a href="/" class="d-flex align-items-center mb-3 mb-md-0 me-md-auto text-dark text-decoration-none">

            <span class="fs-4">Rahul</span>
        </a>

        <ul class="nav nav-pills">
            <li class="nav-item"><a href="/" class="nav-link" aria-current="page">Home</a></li>
            <li class="nav-item"><a class="nav-link" href="/git">Git</a></li>
            <li class="nav-item"><a class="nav-link" href="/docker">Docker</a></li>
            <li class="nav-item"><a class="nav-link" href="/python">Python/Flask</a></li>
            <li class="nav-item"><a class="nav-link" href="/cicd">CI/CD</a></li>
            <li class="nav-item"><a class="nav-link" href="/aaa">AAA</a></li>
            <li class="nav-item"><a class="nav-link" href="/oops">OOPS</a></li>
            <li class="nav-item"><a class="nav-link active" href="/solid">SOLID</a></li>
            <li class="nav-item"><a class="nav-link" href="/pylint">Pylint/Others</a></li>
            <li class="nav-item"><a class="nav-link" href="/glos">Glossary</a></li>
        </ul>
    </header>
    <div class="row">

        <div class="col-8">

            <h3>Single-Responsibility Principle:</h3>
            <a href="https://levelup.gitconnected.com/s-o-l-i-d-principles-explained-in-python-with-examples-83b2b43bdcde">Reference</a>
            <br><br>

            <div class="row">
                <div class="column">
                    <img src="/static/images/S.png" style="width:100%">
                    <p class="center">A</p>
                </div>

            </div>
            <br>



            <p>
                This class itself uses the <strong>Single-Responsibility Principle</strong>
                since each class needs to be responsible
                for one concept. Here in this example, <strong>Addition Class</strong>
                has one function, <strong>add()</strong>. This function
                has one concept meant to get the addition results. This class alongside with the other classes that
                uses the <strong>Single-Responsibility Principle:</strong>
            </p>

            <ul>
                <li>Addition()</li>
                <li>Subtraction()</li>
                <li>Multiplication()</li>
                <li>Division()</li>
            </ul>

            <p>All have generally one concept hence if you change anything in these classes it will ultimately effect
                only one behavior of the software. </p>
            <hr><br>


            <h3>Open-Closed Principle:</h3>
            <a href="https://levelup.gitconnected.com/s-o-l-i-d-principles-explained-in-python-with-examples-83b2b43bdcde">Reference</a>
            <br><br>

            <div class="row">
                <div class="column">
                    <img src="/static/images/In1.png" style="width:100%">
                    <p class="center">A</p>
                </div>
                <div class="column">
                    <img src="/static/images/In2.png" style="width:100%">
                    <p class="center">B</p>
                </div>
            </div><br>

            <p>In image(A) you can see the class <strong>Addition</strong>
                which is inherited from the class <strong>Calculation</strong>.</p>

            <p>Open-Closed Principle states that objects or entities should be open for extension but closed for
                modification. In image(B) we can see that for classes:</p>

            <ul>
                <li>Addition()</li>
                <li>Subtraction()</li>
                <li>Multiplication()</li>
                <li>Division()</li>
            </ul>

            <p>Are all extensions of class <strong>Calculation</strong>. Instead of having all the functions that
                each of these classes
            have, we would add new logic to the corresponding classes seen above.</p>

            <hr><br><h3>Liskov Substitution Principle:</h3>
            <a href="https://levelup.gitconnected.com/s-o-l-i-d-principles-explained-in-python-with-examples-83b2b43bdcde">Reference</a>
            <br><br>

            <div class="row">
                <div class="column">
                    <img src="/static/images/a1.png" style="width:100%">
                    <p class="center">A</p>
                </div>
                <div class="column">
                    <img src="/static/images/S.png" style="width:100%">
                    <p class="center">B</p>
                </div>
            </div><br>

            <p>Since we can’t replace the parent class’s functionality, we can re -write it in the child class
                for modification. In Image(A) above this represents the <strong>child class</strong>,
                Image(B) represents the <strong>parent class</strong>.</p>

            <p>In order to abide by the rules of <strong>Liskov Subsitution Principle</strong>, we duplicate the
                <strong>Parent class</strong>
                into the <strong>Child class</strong>
                and then write the desired modifications within the <strong>child class</strong>.</p>

            <hr><br><h3>Interface Segregation Principle:</h3>
            <a href="https://levelup.gitconnected.com/s-o-l-i-d-principles-explained-in-python-with-examples-83b2b43bdcde">Reference</a>
            <br><br>
            <div class="row">
                <div class="column">
                    <img src="/static/images/In1.png" style="width:100%">
                    <p class="center">A</p>
                </div>
                <div class="column">
                    <img src="/static/images/In2.png" style="width:100%">
                    <p class="center">B</p>
                </div>
            </div><br>

            <p><strong>Interface Segregation Principle</strong> defines that by segregating the role-based methods into smaller
                role interfaces, the clients would depend only on the methods that are relevant to it.
                As shown in the above images, this is the correct implementation of Interface Segregation Principle
                since the abstract methods <strong>create()</strong> and <strong>convert_args_to_tuple_of_float()
                </strong> are not large interfaces
                instead they are smaller interfaces which the classes shown below would inherit:</p>

            <ul>
                <li>Addition()</li>
                <li>Subtraction()</li>
                <li>Multiplication()</li>
                <li>Division()</li>
            </ul>
            <p>By segregating the role-based methods into smaller role interfaces, it will depend on the methods that are relevant to it. </p>



            <hr><br><h3>Dependency Inversion Principle:</h3>
            <a href="https://levelup.gitconnected.com/s-o-l-i-d-principles-explained-in-python-with-examples-83b2b43bdcde">Reference</a>
            <br><br>
            <div class="row">
                <div class="column">
                    <img src="/static/images/In1.png" style="width:100%">
                    <p class="center">A</p>
                </div>
                <div class="column">
                    <img src="/static/images/In2.png" style="width:100%">
                    <p class="center">B</p>
                </div>
            </div><br>
            <p>As shown in the image above, the classes shown below depend on the
                abstractions and not concretions. Since <strong>Dependency Inversion Principle</strong>
                defines that <strong>High-level/Low-level modules</strong> and there details depend on
                the abstractions, we can validate that with the two abstractions classes,
                <strong>create()</strong> and <strong>convert_args_to_tuple_of_float()</strong>. These classes
                serve as the
                parent class in which the classes below depend on. </p>
            <ul>
                <li>Addition()</li>
                <li>Subtraction()</li>
                <li>Multiplication()</li>
                <li>Division()</li>
            </ul>

        </div>

        <div class="col">


            <div class="d-flex flex-column align-items-stretch flex-shrink-0" style="width: 380px;">


                <h3>Factory Design Pattern:</h3>
                <a href="https://refactoring.guru/design-patterns/factory-method/python/example">Reference</a>
                <br><br>
            <div class="row">
                <div class="column">
                    <img src="/static/images/In1.png" style="width:100%">
                    <p class="center">A</p>
                </div>

            </div><br>
                <p>This is a creational design pattern which solves the problem of creating product objects without
                    specifying their concrete classes.</p>
                <hr>
                <p>Class <strong>Calculation()</strong> declares the factory method that is supposed to return an object
                of the product class. The subclasses of <strong>Calculation()</strong> provide the implementation of
                this method.</p>
                <hr>
                <p>Class <strong>create()</strong> provides the default implementation of the factory method.</p>

                <hr>
                <p>Class <strong>Calculation()</strong> primary responsibility is to contain some logic that relies on
                the products object returned by the factory method. Subclasses of this can change the logic by
                overriding the factory method and reutrning different type of product.</p>
            </div>


        </div>
    </div>

</div>

<!-- Optional JavaScript; choose one of the two! -->

<!-- Option 1: Bootstrap Bundle with Popper -->
<script src="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/js/bootstrap.bundle.min.js"
        integrity="sha384-ka7Sk0Gln4gmtz2MlQnikT1wXgYsOg+OMhuP+IlRH9sENBO0LRn5q+8nbTov4+1p"
        crossorigin="anonymous"></script>

<!-- Option 2: Separate Popper and Bootstrap JS -->
<!--
<script src="https://cdn.jsdelivr.net/npm/@popperjs/core@2.10.2/dist/umd/popper.min.js" integrity="sha384-7+zCNj/IqJ95wo16oMtfsKbZ9ccEh31eOz1HGyDuCQ6wgnyJNSYdrPa03rtR1zdB" crossorigin="anonymous"></script>
<script src="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/js/bootstrap.min.js" integrity="sha384-QJHtvGhmr9XOIpI6YVutG+2QOK9T+ZnN4kzFN1RtK3zEFEIsxhlmWl5/YESvpZ13" crossorigin="anonymous"></script>
-->
<script src="{{ url_for('static', filename='js/scripts.js') }}"></script>
<script>
    //Get the button
    var mybutton = document.getElementById("myBtn");

    // When the user scrolls down 20px from the top of the document, show the button
    window.onscroll = function () {
        scrollFunction()
    };

    function scrollFunction() {
        if (document.body.scrollTop > 20 || document.documentElement.scrollTop > 20) {
            mybutton.style.display = "block";
        } else {
            mybutton.style.display = "none";
        }
    }

    // When the user clicks on the button, scroll to the top of the document
    function topFunction() {
        document.body.scrollTop = 0;
        document.documentElement.scrollTop = 0;
    }
</script>
</body>
</html>